# New Features in C++11

## Chapter 2 Variables and Basic Types

✓ 2.1.1 long long Type

✓ 2.2.1 List Initialization

✓ 2.3.2 nullptr Literal

✓ 2.4.4 constexpr Variables

✓ 2.5.1 Type Alias Declarations

✓ 2.5.2 The auto Type Specifier

✓ 2.5.3 The decltype Type Specifier

✓ 2.6.1 In-Class Initializers

## Chapter 3 Strings, Vectors, and Arrays

3.2.2 Using auto or decltype for Type Abbreviation

3.2.3 Range for Statement

3.3 Defining a vector of vectors

3.3.1 List Initialization for vectors

3.4.1 Container cbegin and cend Functions

3.5.3 Library begin and end Functions

3.6 Using auto or decltype to Simplify Declarations

## Chapter 4 Expressions

4.2 Rounding Rules for Division

4.4 Assignment from a Braced List of Values

4.9 sizeof Applied to a Class Member

## Chapter 5 Statements

5.4.3 Range for Statement

## Chapter 6 Functions

6.2.6 Library initializer_list Class

6.3.2 List Initializing a Return Value

6.3.3 Declaring a Trailing Return Type

6.3.3 Using decltype to Simplify Return Type Declarations

6.5.2 constexpr Functions

## Chapter 7 Classes

7.1.4 Using = default to Generate a Default Constructor

7.3.1 In-class Initializers for Members of Class Type

7.5.2 Delegating Constructors

7.5.6 constexpr Constructors

## Chapter 8 The IO Library

8.2.1 Using strings for File Names

## Chapter 9 Sequential Containers

9.1 The array and forward_list Containers

9.2.3 Container cbegin and cend Functions

9.2.4 List Initialization for Containers

9.2.5 Container Nonmember swap Functions

9.3.1 Return Type for Container insert Members

9.3.1 Container emplace Members

9.4 shrink_to_fit

9.5.5 Numeric Conversion Functions for strings

## Chapter 10 Generic Algorithms

10.3.2 Lambda Expressions

10.3.3 Trailing Return Type in Lambda Expressions

10.3.4 The Library bind Function

## Chapter 11 Associative Containers

11.2.1 List Initialization of an Associative Container

11.2.3 List Initializing pair Return Type

11.3.2 List Initialization of a pair

11.4 The Unordered Containers

## Chapter 12 Dynamic Memory

12.1 Smart Pointers

12.1.1 The shared_ptr Class

12.1.2 List Initialization of Dynamically Allocated Objects

12.1.2 auto and Dynamic Allocation

12.1.5 The unique_ptr Class

12.1.6 The weak_ptr Class

12.2.1 Range for Doesn’t Apply to Dynamically Allocated Arrays .

12.2.1 List Initialization of Dynamically Allocated Arrays

12.2.1 auto Can’t Be Used to Allocate an Array

12.2.2 allocator::construct Can Use any Constructor

## Chapter 13 Copy Control

13.1.5 Using = default for Copy-Control Members

13.1.6 Using = delete to Prevent Copying Class Objects

13.5 Moving Instead of Copying Class Objects

13.6.1 Rvalue References

13.6.1 The Library move Function

13.6.2 Move Constructor and Move Assignment

13.6.2 Move Constructors Usually Should Be noexcept

13.6.2 Move Iterators

13.6.3 Reference Qualified Member Functions

## Chapter 14 Overloaded Operations and Conversions

14.8.3 The function Class Template

14.9.1 explicit Conversion Operators

## Chapter 15 Object-Oriented Programming

15.2.2 override Specifier for Virtual Functions

15.2.2 Preventing Inheritance by Defining a Class as final

15.3 override and final Specifiers for Virtual Functions

15.7.2 Deleted Copy Control and Inheritance

15.7.4 Inherited Constructors

## Chapter 16 Templates and Generic Programming

16.1.2 Declaring a Template Type Parameter as a Friend

16.1.2 Template Type Aliases

16.1.3 Default Template Arguments for Template Functions

16.1.5 Explicit Control of Instantiation

16.2.3 Template Functions and Trailing Return Types

16.2.5 Reference Collapsing Rules

16.2.6 static_cast from an Lvalue to an Rvalue

16.2.7 The Library forward Function

16.4 Variadic Templates

16.4 The sizeof... Operator

16.4.3 Variadic Templates and Forwarding

## Chapter 17 Specialized Library Facilities

17.1 The Library Tuple Class Template

17.2.2 New bitset Operations

17.3 The Regular Expression Library

17.4 The Random Number Library

17.5.1 Floating-Point Format Control

## Chapter 18 Tools for Large Programs

18.1.4 The noexcept Exception Specifier

18.1.4 The noexcept Operator

18.2.1 Inline Namespaces

18.3.1 Inherited Constructors and Multiple Inheritance

## Chapter 19 Specialized Tools and Techniques

19.3 Scoped enums

19.3 Specifying the Type Used to Hold an enum

19.3 Forward Declarations for enums

19.4.3 The Library mem_fn Class Template

19.6 Union Members of Class Types
